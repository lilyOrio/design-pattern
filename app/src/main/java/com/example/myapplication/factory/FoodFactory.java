package com.example.myapplication.factory;
/**
 *  1、简单工厂模式
 * 简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，
 * 返回不同的派生自同一个父类（或实现同一接口）的实例对象。
 *  2、工厂模式
 * 之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。
 * 核心在于，我们需要在第一步选好我们需要的工厂。比如，我们有 LogFactory 接口，实现类有 FileLogFactory
 * 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化
 * FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。
 *  3、抽象工厂模式
 * 当涉及到产品族的时候，就需要引入抽象工厂模式了。
 * 我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的
 * 设备，这样能保证肯定不存在兼容问题。
 * 当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器
 * 的方法。这有点违反了对修改关闭，对扩展开放这个设计原则。
 * */
public class FoodFactory {
}
